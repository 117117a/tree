<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>树洞</title>
<style>
  body {
    background: linear-gradient(120deg, #f0f8ff, #e0ffff);
    overflow: hidden;
    height: 100vh;
    margin: 0;
    font-family: '微软雅黑', sans-serif;
  }

  .barrage {
    position: absolute;
    white-space: nowrap;
    font-weight: bold;
    animation: moveLeft linear forwards;
    text-shadow: 1px 1px 3px rgba(0,0,0,0.15);
  }

  @keyframes moveLeft {
    from { transform: translateX(100vw); }
    to { transform: translateX(-100%); }
  }
</style>
</head>
<body>
<script>
const messagesFront = [
  'lonely','excited','calm','relaxed','surprised','nervous',
  'disappointed','happy','amazed','upset','sad','scared','hopeful'
];

const messagesBack = [
  'Take a deep breath and smell something good.',
  'Go out to enjoy the nature.',
  'Talk with your family or friends.',
  'Watch a fun movie.',
  'Have a trip.',
  'Have something delicious.',
  'And we can give each other a big hug.'
];

const fontSize = 36;
const animationDuration = 15; // 秒
const interval = 800; // ms 发送间隔
const minSpacing = fontSize + 10; // 文字之间最小间距

// 生成固定高度，均匀分布
function generateHeights(count) {
  const screenHeight = window.innerHeight;
  const spacing = Math.floor((screenHeight - fontSize) / count);
  const heights = [];
  for (let i = 0; i < count; i++) {
    heights.push(i * spacing);
  }
  return heights;
}

// 打乱数组顺序
function shuffle(array) {
  const arr = array.slice();
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

const frontHeights = generateHeights(messagesFront.length);
const backHeights = generateHeights(messagesBack.length);

// 检查高度是否与当前屏幕上的文字重叠
function getAvailableHeight(candidateHeights) {
  const activeBarrages = document.querySelectorAll('.barrage');
  for (let h of candidateHeights) {
    let conflict = false;
    for (let b of activeBarrages) {
      const rect = b.getBoundingClientRect();
      if (Math.abs(rect.top - h) < minSpacing) {
        conflict = true;
        break;
      }
    }
    if (!conflict) return h;
  }
  return null; // 没找到可用高度
}

function createBarrage(msg, candidateHeights, type) {
  const topPos = getAvailableHeight(candidateHeights);
  if (topPos === null) return false; // 没有可用高度，跳过发送

  const barrage = document.createElement('div');
  barrage.className = 'barrage';
  barrage.innerText = msg;
  barrage.style.top = topPos + 'px';
  barrage.style.fontSize = fontSize + 'px';
  
  barrage.style.color = type === 'front' 
    ? `hsl(${Math.random()*360}, 85%, 55%)` 
    : `hsl(${Math.random()*360}, 70%, 65%)`;

  barrage.style.animationDuration = animationDuration + 's';
  document.body.appendChild(barrage);

  setTimeout(() => barrage.remove(), (animationDuration + 1)*1000);
  return true;
}

// 播放一组弹幕
async function playGroup(messages, heights, type) {
  const shuffledHeights = shuffle(heights);
  for (let i = 0; i < messages.length; i++) {
    let sent = false;
    while(!sent) {
      sent = createBarrage(messages[i], shuffledHeights, type);
      if (!sent) await new Promise(res => setTimeout(res, 200)); // 等待高度空出
    }
    await new Promise(res => setTimeout(res, interval));
  }
  await new Promise(res => setTimeout(res, 230)); // 缩短组间间隔
}

// 主循环
async function loopPlay() {
  while (true) {
    await playGroup(messagesFront, frontHeights, 'front');
    await playGroup(messagesBack, backHeights, 'back');
  }
}

loopPlay();
</script>
</body>
</html>
